#include "Ast.h"
#include "SymbolTable.h"
#include "Unit.h"
#include "Instruction.h"
#include "IRBuilder.h"
#include <memory>
#include <stack>
#include <string>
#include "Type.h"
#include <vector>
#include <cassert>
#include <functional>

extern FILE *yyout;
int Node::counter = 0;
IRBuilder* Node::builder = nullptr;
std::vector<BasicBlock*> global_cond_bb{};
std::vector<BasicBlock*> global_end_bb{};
Operand* zeroop = new Operand(new IntSymbolEntry(TypeSystem::intType,0));
Operand* fzeroop = new Operand(new FloatSymbolEntry(TypeSystem::floatType,0));
Instruction* gbb{};
std::vector<Instruction*> waitinginst{};

Node::Node()
{
    seq = counter++;
}

void Node::backPatch(std::vector<BasicBlock*> &list, BasicBlock*target, bool istrue)
{
    if(istrue)
    {
        for(auto& node : list)
        {
            dynamic_cast<CondBrInstruction*>(node->rbegin())->setTrueBranch(target);
        }
    }
    else
    {
        for(auto& node : list)
        {
            dynamic_cast<CondBrInstruction*>(node->rbegin())->setFalseBranch(target);
        }
    }
}

std::vector<BasicBlock*> Node::merge(std::vector<BasicBlock*> &list1, std::vector<BasicBlock*> &list2)
{
    std::vector<BasicBlock*> res(list1);
    res.insert(res.end(), list2.begin(), list2.end());
    return res;
}

void Ast::genCode(Unit *unit)
{
    IRBuilder *builder = new IRBuilder(unit);
    Node::setIRBuilder(builder);
    unit->getbb() = new DummyInstruction();
    gbb = unit->getbb();
    root->genCode();
}

void FunctionDef::genCode()
{
    Unit *unit = builder->getUnit();
    Function *func = new Function(unit, se);
    BasicBlock *entry = func->getEntry();
    // set the insert point to the entry basicblock of this function.
    builder->setInsertBB(entry);
    if(fparams!=nullptr&&!fparams->getVector().empty())
    {
        std::vector<SymbolEntry *> p{};
        for(auto& node : fparams->getVector())
        {
                Instruction *alloca;
                Operand *addr;
                SymbolEntry *addr_se;
                Type *type;
                type = new PointerType(node->getSymPtr()->getType());
                addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
                addr = new Operand(addr_se);
                alloca = new AllocaInstruction(addr, node->getSymPtr());
                new StoreInstruction(addr,new Operand(node->getSymPtr()),entry);
                entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
                dynamic_cast<IdentifierSymbolEntry*>(node->getSymPtr())->setAddr(addr);
                p.emplace_back(node->getSymPtr());     
            
        }
        func->changeParams(p);
    }
    stmt->genCode();
    if(dynamic_cast<FunctionType*>(se->getType())->getRetType()->isVoid())
    {
        new RetInstruction(nullptr,builder->getInsertBB());
    }
}

void BinaryExpr::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    Function *func = bb->getParent();
    if (op == AND)
    {
        BasicBlock *trueBB = new BasicBlock(func);  // if the result of lhs is true, jump to the trueBB.
        expr1->genCode();
        if(expr1->getOperand()->getType()!=TypeSystem::boolType)
        {
            auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
            new CmpInstruction(CmpInstruction::NEQUAL, tempdst, expr1->getOperand(), expr1->getOperand()->getType()->isInt()?zeroop:fzeroop, builder->getInsertBB());
            new CondBrInstruction(builder->getInsertBB(),tempdst);
        }
        else
        {
            new CondBrInstruction(builder->getInsertBB(),expr1->getOperand());
        }
        addPredAndSucc(builder->getInsertBB(),trueBB);
        backPatch(expr1->trueList(), trueBB,true);

        builder->setInsertBB(trueBB);               // set the insert point to the trueBB so that intructions generated by expr2 will be inserted into it.
        expr2->genCode();
        dst = expr2->getOperand();
        true_list = expr2->trueList();
        false_list = merge(expr1->falseList(), expr2->falseList());
        
    }
    else if(op == OR)
    {
        BasicBlock *falseBB = new BasicBlock(func);
        expr1->genCode();
        if(expr1->getOperand()->getType()!=TypeSystem::boolType)
        {
            auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
            new CmpInstruction(CmpInstruction::NEQUAL, tempdst, expr1->getOperand(), expr1->getOperand()->getType()->isInt()?zeroop:fzeroop, builder->getInsertBB());
            new CondBrInstruction(builder->getInsertBB(),tempdst);
        }
        else
        {
            new CondBrInstruction(builder->getInsertBB(),expr1->getOperand());
        }
        addPredAndSucc(builder->getInsertBB(),falseBB);
        backPatch(expr1->falseList(), falseBB,false);
        builder->setInsertBB(falseBB);
        expr2->genCode();
        dst = expr2->getOperand();
        false_list = expr2->falseList();
        true_list = merge(expr1->trueList(), expr2->trueList());

    }
    else if(op >= LESS && op <= GREATER)
    {
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case LESS:
            opcode = CmpInstruction::LESS;
            break;
        case GREATER:
            opcode = CmpInstruction::GREATER;
            break;
        case NLESS:
            opcode = CmpInstruction::NLESS;
            break;
        case NGREATER:
            opcode = CmpInstruction::NGREATER;
            break;
        case EQUAL:
            opcode = CmpInstruction::EQUAL;
            break;
        case NEQUAL:
            opcode = CmpInstruction::NEQUAL;
            break;
        default:
            opcode = -1;
            break;
        }
        new CmpInstruction(opcode, dst, src1, src2, bb);
        dst->changeType(TypeSystem::boolType);
        this->trueList().emplace_back(bb);
        this->falseList().emplace_back(bb);
    }
    else if(op >= ADD && op <= SUB)
    {
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case ADD:
            opcode = BinaryInstruction::ADD;
            break;
        case SUB:
            opcode = BinaryInstruction::SUB;
            break;
        case MUL:
            opcode = BinaryInstruction::MUL;
            break;
        case DIV:
            opcode = BinaryInstruction::DIV;
            break;
        case MOD:
            opcode = BinaryInstruction::MOD;
            break;
        default:
            opcode = -1;
            break;
        }
        new BinaryInstruction(opcode, dst, src1, src2, bb);
        this->trueList().emplace_back(bb);
        this->falseList().emplace_back(bb);
    }
}
void UnaryExpr::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    if(op==FUNCCALL)
    {
        std::vector<Operand*> ops{};
        if(params!=nullptr)
        {
            for(const auto& node:params->getVector())
            {
                node->genCode();
                ops.emplace_back(node->getOperand());
            }
        }
        if(dynamic_cast<FunctionType*>(funcse->getType())->getRetType()==TypeSystem::voidType)
        {
            new CallInstruction(nullptr, funcse, ops, bb);
        }
        else
        {
            if(dynamic_cast<FunctionType*>(funcse->getType())->getRetType()==TypeSystem::floatType)
            {
                dst->changeType(TypeSystem::floatType);
            }
            new CallInstruction(dst, funcse, ops, bb);
        }
        this->trueList().emplace_back(bb);
        this->falseList().emplace_back(bb);
    }
    else
    {
        expr->genCode();
        Operand *src = expr->getOperand();
        int opcode;
        switch(op)
        {
            case ADD:
                opcode = UnaryInstruction::ADD;
                if(src->getType()!=TypeSystem::boolType)
                {
                    new UnaryInstruction(opcode, dst, src, bb);
                }
                else
                {
                    auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()));
                    new ZextInstruction(tempdst, src, bb);
                    new UnaryInstruction(opcode, dst, tempdst, bb);
                }
                break;
            case SUB:
                opcode = UnaryInstruction::SUB;
                if(src->getType()!=TypeSystem::boolType)
                {
                    new UnaryInstruction(opcode, dst, src, bb);
                }
                else
                {
                    auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()));
                    new ZextInstruction(tempdst, src, bb);
                    new UnaryInstruction(opcode, dst, tempdst, bb);
                }
                break;
            case NOT:
                opcode = UnaryInstruction::NOT;
                if(src->getType()!=TypeSystem::boolType)
                {
                    auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
                    dst->changeType(TypeSystem::boolType);
                    new CmpInstruction(CmpInstruction::NEQUAL, tempdst, src, src->getType()->isInt()?zeroop:fzeroop, bb);
                    new UnaryInstruction(opcode, dst, tempdst, bb);
                }
                else
                {
                    dst->changeType(TypeSystem::boolType);
                    new UnaryInstruction(opcode, dst, src, bb);
                }
                break;
            default:
                opcode = -1;
                break;
        }
        this->trueList().emplace_back(bb);
        this->falseList().emplace_back(bb);
    }
}

void CallParams::genCode()
{

}//TOOOOOOOOODO

void Constant::genCode()
{
    this->trueList().emplace_back(builder->getInsertBB());
    this->falseList().emplace_back(builder->getInsertBB());
}

void Id::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();
    Operand * src = addr;
    if(!arr->empty())
    {
        if(!dynamic_cast<PointerType*>(addr->getType())->getValue()->isPointer())
        {
            ArrayType arrtype = *(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(addr->getType())->getValue()));
            auto vec = arr->getVector();
            for(auto iter = vec.begin();iter!=vec.end();++iter)
            {
                    if(!(*iter)->getExprNode()->hasInt())
                    {
                        (*iter)->getExprNode()->genCode();
                        arrtype.eraseFirst();
                        Type *temparr;
                        temparr = new PointerType(new ArrayType(arrtype));
                        auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getOperand(), bb);
                        src = tempdst2;
                    }
                    else
                    {
                        arrtype.eraseFirst();
                        Type *temparr;
                        temparr = new PointerType(new ArrayType(arrtype));
                        auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getIntop().value(), bb);
                        src = tempdst2;
                    }
                
            }     
        }
        else
        {
            if(arr->size()==1)
            {
                auto node = arr->getVector().front();
                if(!node->getExprNode()->hasInt())
                {
                    node->getExprNode()->genCode();
                    Type *temparr;
                    if(src->getType()->isInt())
                    {
                        temparr = new PointerType(TypeSystem::intType);
                    }
                    else
                    {
                        temparr = new PointerType(TypeSystem::floatType);
                    }          
                    auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                    new LoadInstruction(tempdst2, src,bb);
                    auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                    new GEPInstruction(tempdst3, tempdst2, node->getExprNode()->getOperand(), bb,true);
                    src = tempdst3;
                }
                else
                {
                    Type *temparr;
                    if(src->getType()->isInt())
                    {
                        temparr = new PointerType(TypeSystem::intType);
                    }
                    else
                    {
                        temparr = new PointerType(TypeSystem::floatType);
                    }     
                    auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                    new LoadInstruction(tempdst2, src,bb);
                    auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                    new GEPInstruction(tempdst3, tempdst2, node->getExprNode()->getIntop().value(), bb,true);
                    src = tempdst3;
                }
            }
            else
            {
                ArrayType arrtype = *(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(dynamic_cast<PointerType*>(addr->getType())->getValue())->getValue())) ;
                auto vec = arr->getVector();
                for(auto iter = vec.begin();iter!=vec.end();++iter)
                {
                    if(iter == vec.begin())
                    {
                        if(!(*iter)->getExprNode()->hasInt())
                        {
                            (*iter)->getExprNode()->genCode();
                            Type *temparr;
                            temparr = new PointerType(new ArrayType(arrtype));
                            auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                            new LoadInstruction(tempdst2, src,bb);
                            auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                            new GEPInstruction(tempdst3, tempdst2, (*iter)->getExprNode()->getOperand(), bb,true);
                            src = tempdst3;
                        }
                        else
                        {
                            Type *temparr;
                            temparr = new PointerType(new ArrayType(arrtype));
                            auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                            new LoadInstruction(tempdst2, src,bb);
                            auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                            new GEPInstruction(tempdst3, tempdst2, (*iter)->getExprNode()->getIntop().value(), bb,true);
                            src = tempdst3;
                        }
                    }
                    else
                    {
                        if(!(*iter)->getExprNode()->hasInt())
                        {
                            (*iter)->getExprNode()->genCode();
                            arrtype.eraseFirst();
                            Type *temparr;
                            temparr = new PointerType(new ArrayType(arrtype));
                            auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                            new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getOperand(), bb);
                            src = tempdst2;
                        }
                        else
                        {
                            arrtype.eraseFirst();
                            Type *temparr;
                            temparr = new PointerType(new ArrayType(arrtype));
                            auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                            new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getIntop().value(), bb);
                            src = tempdst2;
                        }
                    }
                }    
            }
        }
        if(!dynamic_cast<PointerType*>(src->getType())->getValue()->isArray()
            ||dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(src->getType())->getValue())->getDims().empty())
        {
            if(src->getType()->isInt())
            {
                src->changeType(new PointerType(TypeSystem::intType));
            }
            else
            {
                src->changeType(new PointerType(TypeSystem::floatType));
            }          
            if(dst->getType()->isInt())
            {
                dst->changeType(TypeSystem::intType);
            }
            else
            {
                dst->changeType(TypeSystem::floatType);
            }
            new LoadInstruction(dst, src, bb);
        }
        else
        {
            auto temptype = *(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(src->getType())->getValue()));
            temptype.eraseFirst();
            if(temptype.getDims().empty())
            {
                if(temptype.isInt())
                {
                    dst->changeType(new PointerType(TypeSystem::intType));
                }
                else
                {
                    dst->changeType(new PointerType(TypeSystem::floatType));
                }
            }
            else
            {
                if(dst->getType()->isInt())
                {
                    dst->changeType(src->getType());
                }
                else
                {
                    dst->changeType(src->getType());
                }
            }
            new GEPInstruction(dst, src,0 ,bb);
        }
    }
    else
    {
        if(dynamic_cast<PointerType*>(addr->getType())->getValue()->isArray())
        {
            ArrayType arrtype = *(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(addr->getType())->getValue()));
            arrtype.eraseFirst();
            Type *temparr;
            if(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(addr->getType())->getValue())->getDims().size()==1)
            {
                if(addr->getType()->isInt())
                {
                    temparr = new PointerType(TypeSystem::intType);
                }
                else
                {
                    temparr = new PointerType(TypeSystem::floatType);
                }
            }
            else
            {
                temparr = new PointerType(new ArrayType(arrtype));
            }
            dst = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
            new GEPInstruction(dst, addr, 0, bb);
        }
        else
        {
            new LoadInstruction(dst, addr, bb);
        }
    }
    this->trueList().emplace_back(bb);
    this->falseList().emplace_back(bb);
}

Operand * Id::genStoreCode()
{
    BasicBlock *bb = builder->getInsertBB();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();
    Operand * src = addr;
    if(!dynamic_cast<PointerType*>(addr->getType())->getValue()->isPointer())
    {
        ArrayType arrtype = *(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(addr->getType())->getValue()));
        auto vec = arr->getVector();
        for(auto iter = vec.begin();iter!=vec.end();++iter)
        {
                if(!(*iter)->getExprNode()->hasInt())
                {
                    (*iter)->getExprNode()->genCode();
                    arrtype.eraseFirst();
                    Type *temparr;
                    temparr = new PointerType(new ArrayType(arrtype));
                    auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                    new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getOperand(), bb);
                    src = tempdst2;
                }
                else
                {
                    arrtype.eraseFirst();
                    Type *temparr;
                    temparr = new PointerType(new ArrayType(arrtype));
                    auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                    new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getIntop().value(), bb);
                    src = tempdst2;
                }
            
        }  
    }
    else
    {
        if(arr->size()==1)
        {
            auto node = arr->getVector().front();
            if(!node->getExprNode()->hasInt())
            {
                node->getExprNode()->genCode();
                Type *temparr;
                if(src->getType()->isInt())
                {
                    temparr = new PointerType(TypeSystem::intType);
                }
                else
                {
                    temparr = new PointerType(TypeSystem::floatType);
                }          
                auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                new LoadInstruction(tempdst2, src,bb);
                auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                new GEPInstruction(tempdst3, tempdst2, node->getExprNode()->getOperand(), bb,true);
                src = tempdst3;
            }
            else
            {
                Type *temparr;
                if(src->getType()->isInt())
                {
                    temparr = new PointerType(TypeSystem::intType);
                }
                else
                {
                    temparr = new PointerType(TypeSystem::floatType);
                }     
                auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                new LoadInstruction(tempdst2, src,bb);
                auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                new GEPInstruction(tempdst3, tempdst2, node->getExprNode()->getIntop().value(), bb,true);
                src = tempdst3;
            }
        }
        else
        {
            ArrayType arrtype = *(dynamic_cast<ArrayType*>(dynamic_cast<PointerType*>(dynamic_cast<PointerType*>(addr->getType())->getValue())->getValue())) ;
            auto vec = arr->getVector();
            for(auto iter = vec.begin();iter!=vec.end();++iter)
            {
                if(iter == vec.begin())
                {
                    if(!(*iter)->getExprNode()->hasInt())
                    {
                        (*iter)->getExprNode()->genCode();
                        Type *temparr;
                        temparr = new PointerType(new ArrayType(arrtype));
                        auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new LoadInstruction(tempdst2, src,bb);
                        auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new GEPInstruction(tempdst3, tempdst2, (*iter)->getExprNode()->getOperand(), bb,true);
                        src = tempdst3;
                    }
                    else
                    {
                        Type *temparr;
                        temparr = new PointerType(new ArrayType(arrtype));
                        auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new LoadInstruction(tempdst2, src,bb);
                        auto tempdst3 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new GEPInstruction(tempdst3, tempdst2, (*iter)->getExprNode()->getIntop().value(), bb,true);
                        src = tempdst3;
                    }
                }
                else
                {
                    if(!(*iter)->getExprNode()->hasInt())
                    {
                        (*iter)->getExprNode()->genCode();
                        arrtype.eraseFirst();
                        Type *temparr;
                        temparr = new PointerType(new ArrayType(arrtype));
                        auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getOperand(), bb);
                        src = tempdst2;
                    }
                    else
                    {
                        arrtype.eraseFirst();
                        Type *temparr;
                        temparr = new PointerType(new ArrayType(arrtype));
                        auto tempdst2 = new Operand(new TemporarySymbolEntry(temparr, SymbolTable::getLabel()));
                        new GEPInstruction(tempdst2, src, (*iter)->getExprNode()->getIntop().value(), bb);
                        src = tempdst2;
                    }
                }
            }   
        }
    } 
    if(src->getType()->isInt())
    {
        src->changeType(new PointerType(TypeSystem::intType));
    }
    else
    {
        src->changeType(new PointerType(TypeSystem::floatType));
    }     
    return src;
}

void IfStmt::genCode()
{
    Function *func;
    BasicBlock *then_bb, *end_bb;

    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    addPredAndSucc(builder->getInsertBB(),then_bb);

    addPredAndSucc(then_bb,end_bb);

    addPredAndSucc(builder->getInsertBB(),end_bb);

    cond->genCode();
    if(cond->getOperand()->getType()!=TypeSystem::boolType)
    {
        auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NEQUAL, tempdst, cond->getOperand(), cond->getOperand()->getType()->isInt()?zeroop:fzeroop, builder->getInsertBB());
        new CondBrInstruction(builder->getInsertBB(),tempdst);
    }
    else
    {
        new CondBrInstruction(builder->getInsertBB(),cond->getOperand());
    }
    backPatch(cond->trueList(), then_bb,true);
    backPatch(cond->falseList(), end_bb,false);

    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(end_bb);

}

void WhileStmt::genCode()
{
    Function *func;
    BasicBlock *then_bb, *end_bb, *current_bb;
    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    current_bb = new BasicBlock(func);
    global_cond_bb.emplace_back(current_bb);
    global_end_bb.emplace_back(end_bb);
    new UncondBrInstruction(current_bb,builder->getInsertBB());
    
    addPredAndSucc(builder->getInsertBB(),current_bb);
    addPredAndSucc(current_bb,then_bb);
    addPredAndSucc(then_bb,end_bb);
    addPredAndSucc(current_bb,end_bb);

    builder->setInsertBB(current_bb);
    cond->genCode();
    if(cond->getOperand()->getType()!=TypeSystem::boolType)
    {
        auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NEQUAL, tempdst, cond->getOperand(), cond->getOperand()->getType()->isInt()?zeroop:fzeroop, builder->getInsertBB());
        new CondBrInstruction(builder->getInsertBB(),tempdst);
    }
    else
    {
        new CondBrInstruction(builder->getInsertBB(),cond->getOperand());
    }
    backPatch(cond->trueList(), then_bb,true);
    backPatch(cond->falseList(), end_bb,false);

    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(current_bb, then_bb);

    global_cond_bb.pop_back();
    global_end_bb.pop_back();
    builder->setInsertBB(end_bb);

}

void IfElseStmt::genCode()//TOOOOOOOOOOOOOOOOOOOOOODO
{
    Function *func;
    BasicBlock *then_bb,*else_bb, *end_bb = nullptr;

    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    else_bb = new BasicBlock(func);
    addPredAndSucc(builder->getInsertBB(),then_bb);
    addPredAndSucc(builder->getInsertBB(),else_bb);
    cond->genCode();
    if(cond->getOperand()->getType()!=TypeSystem::boolType)
    {
        auto tempdst = new Operand(new TemporarySymbolEntry(TypeSystem::boolType, SymbolTable::getLabel()));
        new CmpInstruction(CmpInstruction::NEQUAL, tempdst, cond->getOperand(), cond->getOperand()->getType()->isInt()?zeroop:fzeroop, builder->getInsertBB());
        new CondBrInstruction(builder->getInsertBB(),tempdst);
    }
    else
    {
        new CondBrInstruction(builder->getInsertBB(),cond->getOperand());
    }
    backPatch(cond->trueList(), then_bb,true);
    backPatch(cond->falseList(), else_bb,false);
    
    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    if(!builder->getInsertBB()->end()->getPrev()->isRet())
    {
        if(end_bb==nullptr)
        {
            end_bb = new BasicBlock(func);
        }
        then_bb = builder->getInsertBB();
        new UncondBrInstruction(end_bb, then_bb);
    }
    builder->setInsertBB(else_bb);
    elseStmt->genCode();
    if(!builder->getInsertBB()->end()->getPrev()->isRet())
    {
        if(end_bb==nullptr)
        {
            end_bb = new BasicBlock(func);
        }
        else_bb = builder->getInsertBB();
        new UncondBrInstruction(end_bb, else_bb);
    }
    if(end_bb!=nullptr)
    {
        builder->setInsertBB(end_bb);
        addPredAndSucc(then_bb,end_bb);
        addPredAndSucc(else_bb,end_bb);
    }

}

void BreakStmt::genCode()
{
    new UncondBrInstruction(global_end_bb.back(), builder->getInsertBB());
}

void ContinueStmt::genCode()
{
    new UncondBrInstruction(global_cond_bb.back(), builder->getInsertBB());
}

void CompoundStmt::genCode()
{
    if(stmt!=nullptr)
        stmt->genCode();
}

void SeqNode::genCode()
{
    for(auto& node : stmts)
    {
        node->genCode();
    }
}

void VarId::genCode()
{
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(symbolEntry);
    if(se->isGlobal())
    {
        Operand *addr;
        SymbolEntry *addr_se;
        Instruction *alloca;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        if(isconst())
        {
            assert(initval!=nullptr);
            alloca = new ConstantInstruction(addr, se,initval);
        }
        else
        {
            if(initval == nullptr)
            {   
                alloca = new GlobalInstruction(addr, se);
            }
            else
            {
                alloca = new GlobalInstruction(addr, se,initval);
            }
        }
        alloca->setNext(gbb);
        alloca->setPrev(gbb->getPrev());
        gbb->setPrev(alloca);
        (alloca->getPrev())->setNext(alloca);

        se->setAddr(addr);
    }
    else if(se->isLocal())
    {
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        if(initval == nullptr)
        {   
            alloca = new AllocaInstruction(addr, se);
        }
        else
        {
            if(se->getType()->isArray())
            {
                bool isint = se->getType()->isInt();
                bool isreturn = false;
                alloca = new AllocaInstruction(addr, se);
                std::vector<int> dims = dynamic_cast<ArrayType*>(se->getType())->getDims();
                std::vector<int> status(dims.size());
                std::vector<int> target(dims.size());
                for(size_t i=0;i<target.size();++i)
                {
                    target[i] = dims[i]-1;
                }
                std::function<void(InitVal*, int)> initarr = [&](InitVal* init,int level){
                    if(init->getExprNode()!=nullptr)
                    {   
                        init->getExprNode()->genCode();
                        Operand *src = init->getExprNode()->getOperand();
                        auto tempdst = new Operand(new TemporarySymbolEntry(new PointerType(isint?TypeSystem::intType:TypeSystem::floatType), SymbolTable::getLabel()));
                        new GEPInstruction(tempdst,addr,status,builder->getInsertBB());
                        new StoreInstruction(tempdst,src,builder->getInsertBB());
                        if(status==target)
                        {
                            isreturn = true;
                            return;
                        }
                        for(int i = dims.size()-1;i>=0;--i)
                        {
                            if(status[i]==dims[i]-1)
                            {
                                if(i!=0)
                                {
                                    status[i] = 0;
                                }
                                else
                                {
                                    break;
                                }
                            }
                            else
                            {
                                ++status[i];
                                break;
                            }
                        }

                    }
                    else
                    {
                        auto childs = init->getChilds();
                        for(auto node : childs)
                        {
                            int st = status[level];
                            initarr(node,level+1);
                            if(node->getExprNode()==nullptr)
                            {
                                if(status==target)
                                {
                                    isreturn = true;
                                    return;
                                }
                                std::vector<int> temp(status);
                                bool isboundary = true;
                                for(size_t i = level+1;i<status.size();++i)
                                {
                                    if(status[i] != 0)
                                    {
                                        isboundary=false;
                                        break;
                                    }
                                }
                                if(!isboundary||temp[level]==st)
                                {
                                    status[level]++;
                                    for(size_t i = level+1;i<status.size();++i)
                                    {
                                        status[i] = 0;
                                    }
                                    while(temp!=status)
                                    {
                                        auto tempdst = new Operand(new TemporarySymbolEntry(new PointerType(isint?TypeSystem::intType:TypeSystem::floatType), SymbolTable::getLabel()));
                                        new GEPInstruction(tempdst,addr,temp,builder->getInsertBB());
                                        new StoreInstruction(tempdst,isint?zeroop:fzeroop,builder->getInsertBB());
                                        if(temp==target)
                                        {
                                            isreturn = true;
                                            return;
                                        }
                                        for(int i = dims.size()-1;i>=0;--i)
                                        {
                                            if(temp[i]>=dims[i]-1)
                                            {
                                                if(i!=0)
                                                {
                                                    temp[i] = 0;
                                                }
                                                else
                                                {
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                ++temp[i];
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                initarr(initval,0);
                if(!isreturn||status<target)
                {
                    while(status!=target)
                    {
                        auto tempdst = new Operand(new TemporarySymbolEntry(new PointerType(isint?TypeSystem::intType:TypeSystem::floatType), SymbolTable::getLabel()));
                        new GEPInstruction(tempdst,addr,status,builder->getInsertBB());
                        new StoreInstruction(tempdst,isint?zeroop:fzeroop,builder->getInsertBB());
                        for(int i = target.size()-1;i>=0;--i)
                        {
                            if(status[i]==target[i])
                            {
                                status[i] = 0;
                            }
                            else
                            {
                                ++status[i];
                                break;
                            }
                        }
                    }
                    auto tempdst = new Operand(new TemporarySymbolEntry(new PointerType(isint?TypeSystem::intType:TypeSystem::floatType), SymbolTable::getLabel()));
                    new GEPInstruction(tempdst,addr,status,builder->getInsertBB());
                    new StoreInstruction(tempdst,isint?zeroop:fzeroop,builder->getInsertBB());
                }
            }
            else
            {
                initval->getExprNode()->genCode();
                Operand *src = initval->getExprNode()->getOperand();
                alloca = new AllocaInstruction(addr, se);
                new StoreInstruction(addr,src,builder->getInsertBB());
            }
        }
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.
    }
}

void DeclStmt::genCode()
{
    for(auto& node:ids)
    {
        node->genCode();
    }
}

void ReturnStmt::genCode()
{
    if(retValue!=nullptr)
    {
        retValue->genCode();
        Operand *src = retValue->getOperand();
        Function *func = builder->getInsertBB()->getParent();
        assert(!dynamic_cast<FunctionType*>(func->getSymPtr()->getType())->getRetType()->isVoid());
        if(dynamic_cast<FunctionType*>(func->getSymPtr()->getType())->getRetType()->isInt()&&src->getType()->isFloat())
        {
            auto dst = new Operand(new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel()));
            new FptosiInstruction(dst, src, builder->getInsertBB());
            new RetInstruction(dst,builder->getInsertBB());
        }
        else if(dynamic_cast<FunctionType*>(func->getSymPtr()->getType())->getRetType()->isFloat()&&src->getType()->isInt())
        {
            auto dst = new Operand(new TemporarySymbolEntry(TypeSystem::floatType, SymbolTable::getLabel()));
            new SitofpInstruction(dst, src, builder->getInsertBB());
            new RetInstruction(dst,builder->getInsertBB());
        }
        else
        {
            new RetInstruction(src,builder->getInsertBB());
        }
    }
    else
    {
        Function *func = builder->getInsertBB()->getParent();
        assert(dynamic_cast<FunctionType*>(func->getSymPtr()->getType())->getRetType()->isVoid());
        new RetInstruction(nullptr,builder->getInsertBB());
    }
}

void PlainStmt::genCode()
{
    if(exp!=nullptr)
    {
        exp->genCode();
    }
}

void AssignStmt::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    expr->genCode();
    auto src = expr->getOperand();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(lval->getSymPtr())->getAddr();
    if(dynamic_cast<PointerType*>(addr->getType())->getValue()->isArray()||dynamic_cast<PointerType*>(addr->getType())->getValue()->isPointer())
    {
        auto addr = dynamic_cast<Id*>(lval)->genStoreCode();
        new StoreInstruction(addr, src, bb);
    }
    else
    {
        new StoreInstruction(addr, src, bb);
    }
    /***
     * We haven't implemented array yet, the lval can only be ID. So we just store the result of the `expr` to the addr of the id.
     * If you want to implement array, you have to caculate the address first and then store the result into it.
     */
}

void TDeclStmt::genCode()
{
    st->genCode();
}

void InitVal::genCode()
{
    // Todo
}

void InitVals::genCode()
{
    // Todo
}

void ArrayList::genCode()
{
    // Todo
}

void FArrayList::genCode()
{
    // Todo
}

void FArrayNode::genCode()
{
    // Todo
}

void FuncParams::genCode()
{
    // Todo
}

void FuncParam::genCode()
{
    // Todo
}

void VarIds::genCode()
{
    // Todo
}

void Ast::typeCheck()
{
    if(root != nullptr)
        root->typeCheck();
}

void FunctionDef::typeCheck()
{
    // Todo
}

void BinaryExpr::typeCheck()
{
    // Todo
}

void UnaryExpr::typeCheck()
{
    // Todo
}

void CallParams::typeCheck()
{
    // Todo
}

void BreakStmt::typeCheck()
{
    // Todo
}

void Constant::typeCheck()
{
    // Todo
}

void Id::typeCheck()
{
    // Todo
}

void IfStmt::typeCheck()
{
    // Todo
}

void IfElseStmt::typeCheck()
{
    // Todo
}

void CompoundStmt::typeCheck()
{
    // Todo
}

void SeqNode::typeCheck()
{
    // Todo
}

void WhileStmt::typeCheck()
{
    // Todo
}

void DeclStmt::typeCheck()
{
    // Todo
}

void ReturnStmt::typeCheck()
{
    // Todo
}

void AssignStmt::typeCheck()
{
    // Todo
}

void ContinueStmt::typeCheck()
{
    // Todo
}

void PlainStmt::typeCheck()
{
    // Todo
}

void TDeclStmt::typeCheck()
{
    // Todo
}

void InitVal::typeCheck()
{
    // Todo
}

void InitVals::typeCheck()
{
    // Todo
}

void ArrayNode::typeCheck()
{
    // Todo
}

void ArrayList::typeCheck()
{
    // Todo
}

void FArrayList::typeCheck()
{
    // Todo
}

void FArrayNode::typeCheck()
{
    // Todo
}

void FuncParams::typeCheck()
{
    // Todo
}

void FuncParam::typeCheck()
{
    // Todo
}

void VarId::typeCheck()
{
    // Todo
}

void VarIds::typeCheck()
{
    // Todo
}

void BinaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case AND:
            op_str = "and";
            break;
        case OR:
            op_str = "or";
            break;
        case LESS:
            op_str = "less";
            break;
        case MUL:
            op_str = "mul";
            break;
        case DIV:
            op_str = "div";
            break;
        case MOD:
            op_str = "mod";
            break;
        case GREATER:
            op_str = "greater";
            break;
        case NGREATER:
            op_str = "ngreater";
            break;
        case NLESS:
            op_str = "nless";
            break;
        case EQUAL:
            op_str = "equal";
            break;
        case NEQUAL:
            op_str = "nequal";
            break;
    }
    fprintf(yyout, "%*cBinaryExpr\top: %s\n", level, ' ', op_str.c_str());
    expr1->output(level + 4);
    expr2->output(level + 4);
}

void UnaryExpr::output(int level)
{
    std::string op_str;
    if(op==FUNCCALL)
    {
        fprintf(yyout, "%*cUnaryExpr\top: funccall\n", level, ' ');
        if(params!=nullptr)
        params->output(level + 4);
    }
    else
    {
        switch(op)
        {
            case ADD:
                op_str = "add";
                break;
            case SUB:
                op_str = "sub";
                break;
            case NOT:
                op_str = "not";
                break;
            case NONE:
                op_str = "none";
                break;
        }
        fprintf(yyout, "%*cUnaryExpr\top: %s\n", level, ' ', op_str.c_str());
        expr->output(level + 4);
    }
}

void CallParams::output(int level)
{
    fprintf(yyout, "%*cCallParams\n", level, ' ');
    for(const auto& node : params)
    {
        node->output(level);
    }
}

void FArrayNode::output(int level)
{
    dim->output(level + 4);
}

void FArrayList::output(int level)
{
    fprintf(yyout, "%*cFArrayList\n", level, ' ');
    for(const auto& node : dims)
    {
        node->output(level);
    }
}

void VarId::output(int level)
{
    std::string name, type;
    int scope;
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
    if(arrlist==nullptr||arrlist->getVector().empty())
    {
        fprintf(yyout, "%*cVarId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
            name.c_str(), scope, type.c_str());
    }
    else
    {
        fprintf(yyout, "%*cVarId\tname: %s\tscope: %d\ttype: %s array\n", level, ' ',
            name.c_str(), scope, type.c_str());
        arrlist->output(level+4);
    }
    if(initval!=nullptr)
    {
        initval->output(level+4);
    }
}

void Ast::output()
{
    fprintf(yyout, "program\n");
    if(root != nullptr)
        root->output(4);
}

void Constant::output(int level)
{
    std::string type, value;
    type = symbolEntry->getType()->toStr();
    value = symbolEntry->toStr();
    fprintf(yyout, "%*cIntegerLiteral\tvalue: %s\ttype: %s\n", level, ' ',
            value.c_str(), type.c_str());
}

void FuncParam::output(int level)
{
    std::string name, type;
    int scope;
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
    
    if(isarr)
    {
        fprintf(yyout, "%*cFuncParam\tname: %s\tscope: %d\ttype: %s array\n", level, ' ',
            name.c_str(), scope, type.c_str());
        if(arr!=nullptr)
        {
            arr->output(level+4);
        }
    }
    else
    {
        fprintf(yyout, "%*cFuncParam\tname: %s\tscope: %d\ttype: %s \n", level, ' ',
            name.c_str(), scope, type.c_str());
    }
}

void Id::output(int level)
{
    std::string name, type;
    int scope;
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
    fprintf(yyout, "%*cId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
            name.c_str(), scope, type.c_str());
    if(!arr->empty())
    {
        arr->output(level+4);
    }
}

void CompoundStmt::output(int level)
{
    fprintf(yyout, "%*cCompoundStmt\n", level, ' ');
    if(stmt!=nullptr)
        stmt->output(level + 4);
}

void PlainStmt::output(int level)
{
    fprintf(yyout, "%*cPlainStmt\n", level, ' ');
    if(exp!=nullptr)
    {
        exp->output(level + 4);
    }
}

void SeqNode::output(int level)
{
    fprintf(yyout, "%*cSequence\n", level, ' ');
    for(auto& node : stmts)
    {
        node->output(level+4);
    }
}

void DeclStmt::output(int level)
{
    fprintf(yyout, "%*cDeclStmt\n", level, ' ');
    for(const auto& node : ids)
    {
        node->output(level + 4);
    }
}

void TDeclStmt::output(int level)
{
    fprintf(yyout, "%*cTDeclStmt\n", level, ' ');
    if(st!=nullptr)
    {
        st->output(level + 4);
    }
}

void InitVal::output(int level)
{
    if(expr!=nullptr)
    {
        expr->output(level);
    }
    else
    {
        fprintf(yyout, "%*cInitVal\n", level, ' ');
        for(const auto& node : ids)
        {
            node->output(level+4);
        }
    }
}

void ArrayNode::output(int level)
{
    dim->output(level + 4);
}

void ArrayList::output(int level)
{
    fprintf(yyout, "%*cArrayList\n", level, ' ');
    for(const auto& node : dims)
    {
        node->output(level);
    }
}

void IfStmt::output(int level)
{
    fprintf(yyout, "%*cIfStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
}

void IfElseStmt::output(int level)
{
    fprintf(yyout, "%*cIfElseStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
    elseStmt->output(level + 4);
}

void ReturnStmt::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
    if(retValue!=nullptr)
        retValue->output(level + 4);
}

void AssignStmt::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    lval->output(level + 4);
    expr->output(level + 4);
}

void WhileStmt::output(int level)
{
    fprintf(yyout, "%*cWhileStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
}

void BreakStmt::output(int level)
{
    fprintf(yyout, "%*cBreakStmt\n", level, ' ');
}

void ContinueStmt::output(int level)
{
    fprintf(yyout, "%*cContinueStmt\n", level, ' ');
}

void FuncParams::output(int level)
{
    fprintf(yyout, "%*cFuncParams\n", level, ' ');
    for(const auto& node : params)
    {
        node->output(level);
    }
}

void FunctionDef::output(int level)
{
    std::string name, type;
    name = se->toStr();
    type = se->getType()->toStr();
    fprintf(yyout, "%*cFunctionDefine function name: %s, type: %s\n", level, ' ', 
            name.c_str(), type.c_str());
    stmt->output(level + 4);
}